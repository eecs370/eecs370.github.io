<!DOCTYPE html>
<html lang="en-US">
    <head>
        <meta charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
<!-- Begin Jekyll SEO tag v2.7.1 -->
<meta name="generator" content="Jekyll v3.9.0" />
<meta property="og:locale" content="en_US" />
<link rel="canonical" href="http://localhost:4000/projects/p2_specs.html" />
<meta property="og:url" content="http://localhost:4000/projects/p2_specs.html" />
<meta name="twitter:card" content="summary" />
<script type="application/ld+json">
{"url":"http://localhost:4000/projects/p2_specs.html","@type":"WebPage","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

        <link rel="stylesheet" href="https://eecs485staff.github.io/primer-spec/assets/v1.4/css/primer-spec-base.css">

        <!--
            This page is formatted using Primer Spec.
            Would you like to contribute to the theme?
            Check out: https://github.com/eecs485staff/primer-spec
        -->
        <script>
            window.PrimerSpecConfig = {
                hideSidebarOnLoad: false,
                disableSidebar: false,
                defaultSubthemeName: 'default',
                defaultSubthemeMode: 'system',
            };
        </script>
        <script src="https://eecs485staff.github.io/primer-spec/assets/v1.4/js/primer_spec_plugin.min.js" crossorigin="anonymous" defer></script>
    </head>
    <body>
        <div id="primer-spec-top"></div>
        <div id="primer-spec-app-container" onclick="return true;"></div>

        <div id="primer-spec-plugin-main-content">
            

            <h1 id="project-2-eecs-370-winter-2021">Project 2 EECS 370 (Winter 2021)</h1>

<!-- TODO: update due dates -->
<table>
  <tbody>
    <tr>
      <td>Worth:</td>
      <td>100 points</td>
    </tr>
    <tr>
      <td>Assigned:</td>
      <td>Friday, Febuary 12th, 2021 </td>
    </tr>
    <tr>
      <td>Part 2a Due:</td>
      <td>11:55 PM EST, Friday, Febuary 26th</td>
    </tr>
    <tr>
      <td>Part 2l Due:</td>
      <td>11:55 PM EST, Friday, March 5 </td>
    </tr>
    <tr>
      <td>Part 2c Due:</td>
      <td>11:55 PM EST, Sunday, March 14</td>
    </tr>
    <tr>
      <td>Part 2z <em>OPTIONAL</em> Due:</td>
      <td>11:55 PM EST, Sunday, March 14</td>
    </tr>
  </tbody>
</table>
<h1 id="0-starter-code">0. Starter Code</h1>
<p>We provide <a href="https://drive.google.com/drive/folders/1G2DwUZpcAq-8j59w1nsxznRARjM84vbk">starter code for the linker</a>. For the assembler, you should build on top of the Project 1A Assembler.</p>

<h1 id="1-purpose">1. Purpose</h1>

<p>The purpose of this project is to help you understand the assembling and linking process, which we can utilize to create multi-file LC-2K projects, and to help you understand how procedure calls work in assembly language.</p>

<h1 id="2-problem">2. Problem</h1>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[[assembly files]] -assembler--&gt; [[object files]] -linker--&gt; [executable]
</code></pre></div></div>

<p>This project has three parts. In the <a href="#3-assembler-30">first part</a>, you will write a program that assembles an assembly file into an object file. In the <a href="#4-linker-40">second</a>, you will write a program to link object files into one executable consisting of machine code, which your project 1 simulator will be able to run. In the <a href="#5-assembly-language-function-to-compute-combinationnr-30">third</a>, you will write an assembly-language function to recursively compute combination(n,r)(i.e., n choose r).</p>

<p>In <a href="https://www.eecs.umich.edu/courses/eecs370/eecs370.w20/projects/p1_spec/#4-lc-2k-assembly-language-and-assembler-40">Project 1a</a>, you wrote an assembler which took an LC-2K assembly file as input and produced an executable file as output. This approach is fine if all the code needed is contained in one file, but what happens if we want to use other pieces of code? Libraries contain functions that make coding easier. Splitting code into multiple files encourages modularity and organization. Multiple files are also important for large projects; if you modify one file, you only need to re-assemble that one and then link everything together. Now that we have a better understanding of translation software, we can create a separate assembler and linker.</p>

<h1 id="3-assembler-30">3. Assembler (30%)</h1>

<p>Your new assembler will take in a single assembly file (see <a href="#31-assembly-files">section 3.1</a>) as input and output a single object file (see <a href="#32-object-file-format">section 3.2</a>).</p>

<h2 id="31-assembly-files">3.1. Assembly Files</h2>

<h3 id="311-assembly-file-format">3.1.1 Assembly File Format</h3>

<p>Assembly language programs will be of the same format as those from Project 1, with a few extra restrictions.</p>

<p>The first part of the assembly file must contain only assembly instructions. The second part should contain only <code class="language-plaintext highlighter-rouge">.fill</code> assembler directives. For example, suppose an assembly file is composed of M instructions and N <code class="language-plaintext highlighter-rouge">.fill</code>’s. Lines 0 to (M-1) contain actual instructions, and lines M to (M+N-1) contain <code class="language-plaintext highlighter-rouge">.fill</code>’s, with no mixing between them.</p>

<p>LC-2K files may now use global symbolic addresses, which means we must now distinguish between local and global labels. The scope of a local label is the file the label is defined in. The scope of a global label is all object files linked together (more on this in <a href="#4-linker-40">part 2l</a>). Because of this, different object files can use local labels with the same name and still be linked together.</p>

<p>Local symbolic addresses must be defined at assembly time. However, a global symbolic address can be undefined at assembly time.  It is assumed that undefined global labels are defined in another file to be linked at compile time, so they should be temporarily resolved as address 0 in the text and data segments. Defined symbolic addresses should be resolved exactly as they were in Project 1.</p>

<p>You can assume assembly files max out at 65536 total instructions and data, although we’ll test you on much, much less than that.</p>

<h3 id="312-lc-2k-peculiarities-part-1">3.1.2 LC-2K Peculiarities Part 1</h3>

<p>Firstly, local labels will start with a lowercase letter <code class="language-plaintext highlighter-rouge">a…z</code> while global labels start with a capital letter <code class="language-plaintext highlighter-rouge">A…Z</code>. This is unique to LC-2K as a way to distinguish between local and global labels.</p>

<p>Secondly, if a branch instruction contains a symbolic address, the label it refers to must be a locally defined label. This label can be either a local or global label. Branching to another file (undefined global label) is bad style and makes linking needlessly difficult. A programmer should use jalr in this case. Keep this in mind when considering what to add to the Symbol and Relocation Tables.</p>

<p>Thirdly, in LC-2K, loading or storing to an absolute address no longer makes sense. The locations of data and text within the final executable file will likely be different than in the original object file, leading to unintended execution. While this isn’t something we will enforce with error checking, it is recommended that labels are used when dealing with loads and stores. In reality, there are reasons to use absolute addressing: memory mapped IO for example (if you’re curious about this, take EECS 373 <strong>shameless plug</strong>).  If you come across a label with a constant offset, just assemble as you would in Project 1.</p>

<p>Fourthly, local labels do not require symbol table entries. However, a local symbolic address does need a relocation table entry as the address of the local label might change. These addresses can be fixed by calculating the new local label location during linking.</p>

<h3 id="313-assembly-file-format-summary">3.1.3 Assembly File Format Summary</h3>

<p>In summary, assembly file formatting rules are:</p>

<ol>
  <li>Do not mix instructions with directives (<code class="language-plaintext highlighter-rouge">.fills</code>)</li>
  <li>Instructions come first</li>
  <li>Directives come second</li>
  <li>Defined symbolic addresses are resolved exactly as they were in the Project 1 assembler</li>
  <li>Undefined global symbolic addresses are temporarily resolved as address 0</li>
  <li>Local labels start with <code class="language-plaintext highlighter-rouge">a…z</code> and must be defined at assembly</li>
  <li>Global labels start with <code class="language-plaintext highlighter-rouge">A…Z</code> and can be undefined at assembly</li>
  <li>Branches cannot use undefined global symbolic addresses</li>
  <li>Loads and stores should use symbolic addresses (but are not 
required to)</li>
</ol>

<h2 id="32-object-file-format">3.2 Object File Format</h2>

<p>Object files will contain the following sections in the following order:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Header</code></li>
  <li><code class="language-plaintext highlighter-rouge">Text</code></li>
  <li><code class="language-plaintext highlighter-rouge">Data</code></li>
  <li><code class="language-plaintext highlighter-rouge">Symbol</code> table</li>
  <li><code class="language-plaintext highlighter-rouge">Relocation</code> table</li>
</ul>

<p><em>** Refer to lecture for a detailed explanation of each section. **</em></p>

<p><em>Table 1: Object file sections</em></p>

<table>
  <thead>
    <tr>
      <th>Section Name</th>
      <th>Number of lines</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Header</code></td>
      <td>Fixed: 1</td>
      <td>The <code class="language-plaintext highlighter-rouge">Header</code> contains the size, in  lines, of the sections to follow. Sizes are listed in the following order, each separated by a space: <code class="language-plaintext highlighter-rouge">Text</code>, <code class="language-plaintext highlighter-rouge">Data</code>, <code class="language-plaintext highlighter-rouge">Symbol</code> table, <code class="language-plaintext highlighter-rouge">Relocation</code> table.</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Text</code></td>
      <td>Variable: <code class="language-plaintext highlighter-rouge">t</code> <br /> <code class="language-plaintext highlighter-rouge">t</code> = # of instr.</td>
      <td>Each line in the <code class="language-plaintext highlighter-rouge">Text</code> segment consists of a single machine code instruction, assembled in the same way as instructions in Project 1.</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Data</code></td>
      <td>Variable: <code class="language-plaintext highlighter-rouge">d</code> <br /> <code class="language-plaintext highlighter-rouge">d</code> = # of .fills</td>
      <td>The <code class="language-plaintext highlighter-rouge">Data</code> segment contains data stored by assembler directives, one word of data per line.</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Symbol</code> table</td>
      <td>Variable: <code class="language-plaintext highlighter-rouge">s</code> <br /> <code class="language-plaintext highlighter-rouge">s</code> = # of global labels + # of Unresolved global symbolic addresses</td>
      <td>Each line in the <code class="language-plaintext highlighter-rouge">Symbol</code> table consists of a global label, one letter (T/D/U) corresponding to <code class="language-plaintext highlighter-rouge">Text</code>, <code class="language-plaintext highlighter-rouge">Data</code>, and Undefined respectively, and a line offset from the start of the T/D section (0 if the letter was ‘U’). Each value separated by a space, in that order. Each symbol should only appear once in the symbol table, even if it is used multiple Times. Entries can appear in any order.</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Relocation</code></td>
      <td>Variable: <code class="language-plaintext highlighter-rouge">r</code> <br /> <code class="language-plaintext highlighter-rouge">r</code> = # of symbolic addresses used</td>
      <td>Each line in the <code class="language-plaintext highlighter-rouge">Relocation</code> table consists of a line offset from the start of the T/D section (whichever section the symbol was used in), an opcode, and a label. Each separated by a space, in that order. Entries can appear in any order.</td>
    </tr>
  </tbody>
</table>

<h4 class="primer-spec-toc-ignore" id="important-formatting-notes">IMPORTANT FORMATTING NOTES:</h4>

<ol>
  <li>
    <p>Assembly code in text should be assembled EXACTLY as it was for project 1. This means symbolic addresses are resolved the same, with the exception of undefined global symbolic addresses which are temporarily assembled as 0.</p>
  </li>
  <li>
    <p>Offsets in the Symbol and Relocation Tables indicate the line offset of the label from the start of the either the Text or Data section (whichever the section the label appears in).</p>
  </li>
</ol>

<p>For example, the symbol table entry <code class="language-plaintext highlighter-rouge">Foo D 0</code> indicates the label <code class="language-plaintext highlighter-rouge">Foo</code> is defined on the zeroth line in the Data section. The relocation table entry <code class="language-plaintext highlighter-rouge">4 lw Foo</code> indicates the symbolic address <code class="language-plaintext highlighter-rouge">Foo</code> is used on the fourth line (zero indexed) of the Text section by a <code class="language-plaintext highlighter-rouge">lw</code> instruction.</p>

<!-- TODO: Check that bullets line up properly -->

<h2 id="33-error-checking">3.3 Error Checking</h2>

<p>Your assembler should catch the following errors in assembly files:</p>
<ol>
  <li>Duplicate defined labels (same local or global label within one assembly file)</li>
  <li>Undefined local symbolic address</li>
  <li><code class="language-plaintext highlighter-rouge">beq</code> using an undefined global symbolic address</li>
  <li><code class="language-plaintext highlighter-rouge">offsetFields</code> that don’t fit in 16 bits</li>
  <li>Unrecognized opcodes</li>
</ol>

<p>Your assembler should <code class="language-plaintext highlighter-rouge">exit(1)</code> if it detects an error and <code class="language-plaintext highlighter-rouge">exit(0)</code> if it finishes without detecting any errors. Your assembler should NOT catch simulation-time errors, i.e. errors that would occur at the time the assembly-language program executes (e.g. branching to address -1, infinite loops, etc.).</p>

<h2 id="34-assembly-example">3.4 Assembly example</h2>

<p>Please see <a href="#example-2a">section 9 example 2a</a>.</p>

<h2 id="35-running-your-assembler">3.5 Running Your Assembler</h2>

<p>Write your program to take two command-line arguments. The first argument is the filename where the assembly-language program is stored, and the second argument is the filename where the output (the object file) is written. For example, with a program name of <code class="language-plaintext highlighter-rouge">assemble</code>, an assembly-language program in <code class="language-plaintext highlighter-rouge">program.as</code>, the following would generate an object file <code class="language-plaintext highlighter-rouge">program.obj</code>:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">./assemble program.as program.obj
</span></code></pre></div></div>

<p>Note that the format for running the command must use command-line arguments for the file names (rather than standard input and standard output). Your program should store only object files in the format specified above. Any deviation from this format (e.g. extra spaces or empty lines) will render your machine-code file ungradable. Any other output that you want the program to generate (e.g. debugging output) can be printed to standard output.</p>

<h2 id="36-test-cases">3.6 Test Cases</h2>

<p>The test cases for the assembler part of this project will be short assembly-language programs that serve as input to an assembler. You will
submit your suite of test cases together with your assembler, and we will grade your test suite according to how thoroughly it exercises an assembler. Each test case may be at most 50 lines long, and your test suite may contain up to 20 test cases. These limits are much larger than needed for full credit (the solution test suite is composed of 5 test cases, each &lt; 10 lines long). See <a href="#7-grading-auto-grading-and-formatting">section 7</a> for how your test suite will be graded.</p>

<p>Hint: the example assembly-language program (Example 2a) in <a href="#9-sample-test-cases">section 9</a> is a good case to include in your test suite, though you’ll need to write more test cases to get full credit.  Remember to create some test cases that test the ability of an assembler to check for the errors in <a href="#33-error-checking">section 3.3</a>.</p>

<h1 id="4-linker-40">4. Linker (40%)</h1>

<p>Now that you’ve written an assembler to create object files, you need a way to link these files together. In this part of the project, you will write a linker to combine multiple object files into a single executable.
This final executable will be backwards compatible with the simulator from project 1.</p>

<h2 id="41-lc-2k-linker-description">4.1 LC-2K linker description</h2>

<p>Your linker should be able to take an arbitrary number of object files as input. It will concatenate all text and data segments within each object file, creating one unified executable. Segments should be combined in the order they appear as arguments. The combined text section should be placed before the combined data section. Then, for each object file, the linker iterates through their relocation table. For each relocation entry, the linker iterates through all symbol table entries to locate the label and fix the reference. The final executable will be a machine code file.</p>

<h2 id="42-what-about-main">4.2 What about <code class="language-plaintext highlighter-rouge">main()</code>?</h2>

<p>You might be asking yourself, what will be executed first? Shouldn’t there be a <code class="language-plaintext highlighter-rouge">main()</code> function or label?</p>

<p>To simplify the process of linking and simulating, LC-2K code is executed starting at the first line of in a machine code file. In order to specify what object file should execute first, ordering of the linker’s arguments is needed.</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">./linker file_0.obj file_1.obj machine_code.mc
</span></code></pre></div></div>

<p>In the above example, <code class="language-plaintext highlighter-rouge">file_0.obj</code> contains the first instructions to be executed. The resulting machine code file should be laid out as follows:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>———————— machine_code.mc ————————
        &lt;file_0.obj TEXT&gt;
        &lt;file_1.obj TEXT&gt;
        &lt;file_0.obj DATA&gt;
        &lt;file_1.obj DATA&gt;
</code></pre></div></div>

<p>For more information on the linker’s command line arguments, please see <a href="#47-linker-example">section 4.7</a>. For more information on how linker’s actually handle this, see <a href="#44-lc-2k-peculiarities-part-2">section 4.4</a>.</p>

<h2 id="43-stack-label">4.3 Stack Label</h2>

<p>As discussed in lecture, programs build up stack frames as they execute. The stack is important for storing data that can’t fit within a machine’s registers, such as stack frames and local data. You’ll implement a recursive LC-2K program in <a href="#5-assembly-language-function-to-compute-combinationnr-30">part 2c</a> that will make use of the stack, but we first must provide support for this functionality. As shown in example 2c, this is done by using a global label <code class="language-plaintext highlighter-rouge">Stack</code>.</p>

<p>In LC-2K, the <code class="language-plaintext highlighter-rouge">Stack</code> label is a special label that should not be defined by any object file, but it can be used as a symbolic address. This label is inserted by the linker and should refer to the line after the last piece of data in the data segment. For example, if there are M instructions and N pieces of data in the final executable, the linker should resolve the symbolic address, <code class="language-plaintext highlighter-rouge">Stack</code>, as (M + N). This allows the stack to grow without affecting the instructions or data.</p>

<h2 id="44-lc-2k-peculiarities-part-2">4.4 LC-2K Peculiarities Part 2</h2>

<p>Programming languages often specify where to begin executing. In reality, a linker typically inserts an object file into the linking process. This inserted code appears first and jumps to a specified function to begin executing the program, among doing other things. The LC-2K method of ordering files during the linking process to indicate what to execute first is a simplification.</p>

<p>LC-2K also lacks a proper function call instruction that jumps to labels. It instead jumps to registers that hold function addresses (so the register is a function pointer). This means that a function can have a local label, yet still be accessible from other files, so long as the function pointer is global. Linking should still succeed in this case.</p>

<p>Additionally, LC-2K’s use of the <code class="language-plaintext highlighter-rouge">Stack</code> label doesn’t reflect how all assembly languages use the stack. ARM, for example, has special instructions such as <code class="language-plaintext highlighter-rouge">push</code> and <code class="language-plaintext highlighter-rouge">pop</code> that directly interface with the stack, providing a layer of abstraction to assembly programmers. The stack is typically allocated by an operating system that passes the stack pointer to an executing program.</p>

<h2 id="45-error-checking">4.5 Error Checking</h2>

<p>Your linker should catch the following errors:</p>

<ol>
  <li>duplicate defined global labels</li>
  <li>undefined global labels</li>
  <li><code class="language-plaintext highlighter-rouge">Stack</code> label defined by an object file</li>
</ol>

<p>Your linker can assume that any object file used as input is properly formatted.</p>

<h2 id="46-tip---local-labels">4.6 Tip - Local Labels</h2>

<p>Fixing local symbolic addresses during linking can be tricky, since we don’t have symbol table entries associated with them. It might help to store certain data for each file read in: text size, data size, text starting location (in final mc), and data starting location (in final mc). By also storing which file each relocation table entry is in, you should have all the data needed to adjust each local symbolic address.</p>

<p>Actually fixing a local symbolic address in the relocation involves several steps. First, identify which section of the file the label is in, either text or data. Second, parse the original symbolic address value from the instruction referenced by the relocation entry. Fix this value by adding an offset to the address, to account for the new location of the local label.</p>

<h2 id="47-linker-example">4.7 Linker Example</h2>
<p>Please see <a href="#example-2l">section 9 example 2l</a>.</p>

<h2 id="48-running-your-linker">4.8 Running Your Linker</h2>

<p>Write your program to take N command-line arguments, where N &gt;= 2. The first argument is the object file to execute first, arguments 2 through N-1 are additional object files (these are not required), and the Nth argument is the filename where the machine code output is written. For example, with a program name of <code class="language-plaintext highlighter-rouge">linker</code> and an assembly-language program in <code class="language-plaintext highlighter-rouge">prog_1.obj</code> and <code class="language-plaintext highlighter-rouge">prog_2.obj</code>, the machine code file <code class="language-plaintext highlighter-rouge">prog.mc</code> will be generated:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">./linker prog_1.obj prog_2.obj prog.mc
</span></code></pre></div></div>

<p>The number of object files your linker must be able to link together is between 1 and 6. If a program is self-contained within one object file, your linker should still be able to translate it into a machine code file. We will not test you on linking more than 6 object files.</p>

<p>Note that the format for running the linker must use command-line arguments for file names (rather than standard input and standard output). Your program should store only machine-code in the format specified above. Any deviation from this format (e.g. extra spaces or empty lines) will render your machine-code file ungradable. Any other output that you want the program to generate (e.g. debugging output) can be printed to standard output.</p>

<h2 id="49-test-cases">4.9 Test Cases</h2>

<p>Test cases for the linker part of this project will be short, valid assembly-language programs that, after being assembled into object files, serve as input to a linker. You will submit a suite of test cases together with your linker, and we will grade your test suite according to how thoroughly it exercises an LC-2K linker. Each test assembly file may be at most 50 lines long, and your test suite may contain up to 20 test cases. A test can contain no more than 6 assembly files to be linked together. These limits are much larger than needed for full credit. See <a href="#7-grading-auto-grading-and-formatting">Section 7</a> for how your test suite will be graded.</p>

<p>A naming scheme is needed to specify what test assembly files should be linked together. A single “test” refers to a group of 1 or more assembly files to be linked together. The naming scheme is as follows.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;test name&gt;_&lt;{0, …, N}&gt;.as
</code></pre></div></div>

<p>All tests with the same test name will be assembled and linked together (do not include angled brackets in the test name). An underscore character, ‘_’, separates the test name and the assembly file’s number (do not include angled brackets or curly brackets in the number). Assembly files within the same test should be numbered starting at zero, with the zeroth assembly file being the first code to be executed.</p>

<p>The following testcases:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>test_0.as test_1.as test_2.as anotherTest_0.as anotherTest_1.as 
</code></pre></div></div>

<p>Will be assembled and then linked by the autograder as follows:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">./linker test_0.obj test_1.obj test_2.obj test.mc
./linker anotherTest_0.obj anotherTest_1.obj anotherTest.mc
</span></code></pre></div></div>

<p>DO NOT use more than one underscore in your test case names. We will not grade your test case if you do.</p>

<p>Remember to create some test cases that test the ability of a linker to check for the errors in <a href="#45-error-checking">Section 4.5</a>.</p>

<h1 id="5-assembly-language-function-to-compute-combinationnr-30">5. Assembly-Language Function to Compute Combination(n,r) (30%)</h1>

<p>Write an assembly-language function to recursively compute combination(n,r), defined as:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>combination(n,0) = 1
combination(n,n) = 1
combination(n,r) = combination(n-1,r) + combination(n-1,r-1);

0 &lt;= r &lt;= n
</code></pre></div></div>

<p>Here’s a C function to do this; your assembly-language program may follow this logic closely.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">combination</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="o">==</span><span class="mi">0</span> <span class="o">||</span> <span class="n">n</span><span class="o">==</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">combination</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">r</span><span class="p">)</span> <span class="o">+</span> <span class="n">combination</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">r</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Note that the definition of combination(n,r) is recursive.  Your assembly-language function must also use a recursive function call. That is, your function should call itself twice (to compute <code class="language-plaintext highlighter-rouge">combination(n-1,r)</code> and <code class="language-plaintext highlighter-rouge">combination(n-1,r-1)</code>) and add the results together. This isn’t the most efficient solution (e.g., <code class="language-plaintext highlighter-rouge">n &gt; 9</code> will take a LONG time), but using recursion will help you understand assembly-language procedure calls and stacks. Your program will be passed inputs <code class="language-plaintext highlighter-rouge">n</code> and <code class="language-plaintext highlighter-rouge">r</code> in registers 1 and 2 respectively. Your program should store the result in register 3, which acts as the function’s return value. Straightforward solutions are possible in about 45 lines. If your program is significantly longer than that, you are probably doing something wrong. Your program must be reasonably efficient, i.e., it must execute at most 5000 instructions for <code class="language-plaintext highlighter-rouge">n=7, r=3</code> (this is several times slower than a good solution).</p>

<p>Passing parameters to subroutines can be confusing in assembly language. It’s easiest if you make most registers callee-save so the caller can assume the subroutine leaves those registers unchanged. These callee-saved registers are typically pushed on the stack at the beginning of the subroutine and popped off the stack just before the subroutine returns.</p>

<p>Not all registers can or should be callee-save, however.  For example, one
register will contain the subroutine’s return value. Also, the jalr instruction used to return from the subroutine will leave a register with a different value than it held when the subroutine was called.</p>

<p>The files main.as and sub4n.as are the assembly code for a program that uses a subroutine call. It takes
an argument in register 1 and calls a subroutine to compute the quantity <code class="language-plaintext highlighter-rouge">4*input</code>. Register 1 is used to pass input to the subroutine; register 3 is used by the subroutine to pass the result back. The current top-of-stack (first empty location) is given by <code class="language-plaintext highlighter-rouge">Stack</code> + register 5.</p>
<i> File 1 : main.as </i>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        lw         0        1      input        r1 = memory[input]
        lw         0        4      SubAdr       prepare to call sub4n. r4=addr(sub4n)
        jalr       4        7                   call sub4n; r7=return address r3=answer  
        halt
input   .fill      10</code></pre></div></div>

<i> File 2 : sub4n.as </i>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code>sub4n   lw          0       6       pos1        r6 = 1
        sw          5       7       Stack       save return address on stack
        add         5       6       5           increment stack pointer
        sw          5       1       Stack       save input on stack
        add         5       6       5           increment stack pointer
        add         1       1       1           compute 2*input
        add         1       1       3           compute 4*input into return value
        lw          0       6       neg1        r6 = -1
        add         5       6       5           decrement stack pointer
        lw          5       1       Stack       recover original input
        add         5       6       5           decrement stack pointer
        lw          5       7       Stack       recover original return address
        jalr        7       4                   return.  r4 is not restored.
pos1    .fill       1
neg1    .fill       -1
SubAdr  .fill       sub4n                         contains the address of sub4n</code></pre></div></div>

<p>The stack array starts at the implicit label <code class="language-plaintext highlighter-rouge">Stack</code> and extends to larger addresses, which is why the linker inserts the <code class="language-plaintext highlighter-rouge">Stack</code> label as the last line in the final executable (see <a href="#43-stack-label">section 4.3</a> for more).</p>

<p>The combination function you submit must be an assembly file. Your function will be called by the following main function:</p>
<i> File : combination_main.as </i>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        lw          0       1       n
        lw          0       2       r
        lw          0       4       Caddr        load combination function address
        jalr        4       7                    call function
        halt
n       .fill       7
r       .fill       3</code></pre></div></div>

<p>Your combination function must follow these guidelines:</p>

<ol>
  <li>Accept <code class="language-plaintext highlighter-rouge">n</code> as an argument passed in register 1</li>
  <li>Accept <code class="language-plaintext highlighter-rouge">r</code> as an argument passed in register 2</li>
  <li>Store the starting line of your combination function by including the following line in data:
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Caddr .fill &lt;start_of_function&gt;
</code></pre></div>    </div>
    <p><code class="language-plaintext highlighter-rouge">&lt;start_of_function&gt;</code> is a label at the start of your function</p>
  </li>
  <li>Use recursion by building a stack frame for each function called</li>
  <li>Return the result in register 3</li>
  <li>Use register 7 as the return address</li>
  <li>DO NOT use a global register</li>
  <li>DO NOT use a global register
(Seriously, we’ll detect it.)
<!-- TODO: Check if this renders correctly --></li>
</ol>

<p>A global register is one that all recursive calls to a function use. For example, one could simply increment reg3 at every leaf function. While this would compute a correct result, it does not accurately simulate how a recursive function works.</p>

<p>Make sure your assembly-language function works when assembled and linked with <code class="language-plaintext highlighter-rouge">combination_main.as</code>. Use the Project 2 assembler and linker and the Project 1 simulator, since that’s how we’ll test it. Programs that don’t work with the solution assembler / linker / simulator will <em>receive a 0</em>).</p>

<h2 id="51-tips">5.1 Tips</h2>

<p>One difficult aspect of this program will be allocating variables
in the 8 LC-2K registers. To make your job easier, here are the
register assignments we used–some are enforced, others are not:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>r0  value 0
r1  n input to function - ENFORCED
r2  r input to function - ENFORCED
r3  return value of function - ENFORCED
r4  local variable for function
r5  stack pointer
r6  temporary value (can hold different values at different times, e.g., +1, -1, function address)
r7  return address - ENFORCED
</code></pre></div></div>

<h2 id="52-competition">5.2. Competition</h2>

<p>There is an optional competition this semester for designing an efficient solution to the combination function.  The fastest average across numerous inputs will win a prize.  The only rule is as follows:</p>

<ul>
  <li>You cannot return pre-computed values</li>
</ul>

<p>Anyone who can beat a cycle count of <em>less than 110,000</em> for <code class="language-plaintext highlighter-rouge">C(14,7)</code> will receive 5 bonus points to the project.  Please note the competition will test more than just <code class="language-plaintext highlighter-rouge">C(14,7)</code>, this bar is just to encourage you to attempt this efficient solution.</p>

<p>Late days may <strong>NOT</strong> be used to submit competition functions — we will only accept submissions that come before the deadline listed at the beginning of this document.</p>

<p>The competition leaderboard for project 2Z can be found <a href="https://www.eecs.umich.edu/courses/eecs370/leaderboard.html">here</a>.</p>

<p> Project 2Z is not on the autograder, to submit read the following instructions: </p>
 <p> 
 Firstly, on CAEN navigate to the directory where your file assembly file for 2z is </p>
 <p> Secondly, run the following command: <code> /afs/umich.edu/class/eecs370/bin/submit370 2z [name of assembly file for 2z] </code> </p>
 <p>

 </p>
  <p>Finally, confirm whether or not these are the files you want to submit before it sends them to the grader interface. You will then receive an email with feedback within a few minutes.
  
  You are still limited to 5 submits with feedback per day, so keep that in mind.
  
  This project will be due at 11:55 PM EST, Thursday, March 11 and you cannot use any late days.</p>
<h1 id="6-compiling-the-project">6. Compiling the Project</h1>

<p>Your code will be compiled with the GCC compiler using the C99 standard. The following bash command compiles <code class="language-plaintext highlighter-rouge">program.c</code> and writes the executable into program. You are allowed to use any standard C libraries which compile with the specified flags below.</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">gcc -std=c99 program.c -o program
</span></code></pre></div></div>

<h1 id="7-grading-auto-grading-and-formatting">7. Grading, Auto-Grading, and Formatting</h1>

<p>We will grade primarily on functionality, including error handling, correct assembly, and comprehensiveness of the test suites.</p>

<p>To help you validate your project, your submission will be graded automatically, and the result will be available on the website. You may then continue to work on the project and re-submit. To deter you from using the autograder as a debugger, you will receive feedback from the autograder only for the first <strong>FIVE SUBMISSIONS</strong> for each project part on any given day. All subsequent submissions will be silently graded. Your final score will be derived from your overall <em>best submission</em> to the autograder.</p>

<p>The feedback from the autograder will not be very illuminating; it won’t tell you where your problem is or give you the test programs. The purpose of the autograder is to let you know that you should keep working on your project (rather than thinking it’s perfect and ending up with a 0). The best way to debug your program is to generate your own test cases, figure out the correct answers, and compare your program’s output to the correct answer. This is also one of the best ways to learn the concepts in the project.</p>

<p>The student suites of test cases will be graded according to how thoroughly they test both the assembler (for <a href="#3-assembler-30">part 2a</a>) and linker (for <a href="#4-linker-40">part 2l</a>). We will judge thoroughness of the test suites by how well it exposes potential bugs.</p>

<p>For the assembler test suite, the auto-grader will use each test case as input to a set of buggy assemblers. A test case exposes a buggy assembler by causing it to generate a different answer from a correct assembler.</p>

<p>For the linker test suite, the auto-grader will first assemble the test files and use them as input to a set of buggy linkers. A test case exposes a buggy linker by causing it to generate a different answer from a correct linker. Test cases must use the naming scheme specified in <a href="#49-test-cases">section 4.9</a>.</p>

<p>The test suites are graded based on how many of the buggy assemblers / linkers were exposed by at least one test case. This is known as <code class="language-plaintext highlighter-rouge">mutation testing</code> in the research literature on automated testing.</p>

<h1 id="8-turning-in-the-project">8. Turning in the Project</h1>

<p>Use <a href="https://autograder.io">autograder.io</a> to submit your files.  You have been added as a student to the class, so you should see EECS 370 listed as a class.</p>

<p>Here are the files you should submit for each project part:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. assembler (part 2a)
    a. C program for your assembler called "assembler.c"
    b. suite of test cases (each test case is an assembly-language program in a separate file, ending in ".as")

2. linker (part 2l)
    a. C program for your linker called "linker.c"
    b. Suite of test cases (each test case is a set of assembly-language programs using the naming scheme specified in [section 4.9](TODO:). and ending in ".as"

3. combination (part 2c)
    a. assembly-language function for computing "combination(n,r)" called "combination.as"
</code></pre></div></div>

<h1 id="9-sample-test-cases">9. Sample Test Cases</h1>

<h3 id="example-2a">Example 2a</h3>
<p>Here is a multi-file assembly-language program that counts down from 5, stopping when it hits 0, and then halts:</p>
<i> File 1: main.as </i>
<div class="language-plaintext highlighter-rouge"><pre class="highlight"><code>        lw          0       1       five
        lw          0       4       SubAdr
start   jalr        4       7               
        beq         0       1       done
        beq         0       0       start
done    halt
five    .fill       5</code></pre></div>
<i> File 2: subone.as </i>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>subOne  lw          0       2       neg1
        add         1       2       1         
        jalr        7       6
neg1    .fill       -1
SubAdr  .fill       subOne</code></pre></div></div>

<p>And here are the corresponding object files after running the following lines of code:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">./assembler main.as main.obj
./assembler subone.as subone.obj
</span></code></pre></div></div>
<i> File 1: main.obj </i> (NOTE: Text within parenthesis should not be included in your assembler’s or linker’s output) :
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>6 1 1 2                 (Header) 
8454150                 (Text)
8650752
23527424
16842753
16842749
25165824
5                       (Data)
SubAdr U 0              (Symbol Table)
0 lw five               (Relocation Table)
1 lw SubAdr</code></pre></div></div>
<i> File 2: subone.obj </i> (NOTE: Text within parenthesis should not be included in your assembler’s or linker’s output) :
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>3 2 1 2                 (Header)
8519683                 (Text)
655361
25034752
-1                      (Data)
0
SubAdr D 1              (Symbol Table)
0 lw neg1               (Relocation Table)
1 .fill subOne</code></pre></div></div>
<p><strong>NOTE: Be careful when copying and editing these examples</strong></p>

<h3 id="example-2l">Example 2l</h3>
<p>This example uses the main.obj and subone.obj object files from example 2a. Here is the machine code produced after the linking process:</p>
<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">./linker main.obj subone.obj count5.mc
</span></code></pre></div></div>
<i> File: count5.mc </i> (NOTE: Text within parenthesis should not be included in your assembler’s or linker’s output)
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>8454153             (main.as TEXT)
8650763
23527424
16842753
16842749
25165824
8519690             (subone.as TEXT)
655361
25034752
5                   (main.as DATA)
-1                  (subone.as DATA)
6</code></pre></div></div>

<p>This code can be simulated using your project 1 simulator.</p>

<p><strong>NOTE: Be careful when copying and editing these examples</strong></p>

<h1 id="10-linker-starter-code">10. Linker Starter code</h1>

<p>Referenced starter code is meant to help you read in and parse object files. It is probably a good idea to break it up into different functions, but is a good place to get started.</p>

<p>NOTE: Please see starter file.</p>


            
        </div> <!-- .container-lg -->

        
    </body>
</html>
